<html><head><meta charset="utf-8"/><title>语义工程和PLT Redex</title><link href="styles.css" rel="stylesheet"/></head><body><h1>语义工程和PLT Redex</h1><h2>第1部分 规约语义</h2><h3>第1章 语义via句法</h3><h4>第1.1节 定义集合</h4><p>BNF语法可有多种用途. 一种含义是字符串的集合. 另一种解释是&quot;树&quot;的集合, 其常被称为抽象句法(树). 本书我们总是指后者.</p><p>对于本章和下一章而言, 我们使用下面的BNF语法作为例子:<math display="block"><mtable displaystyle="true"><mtr><mtd><mi>B</mi></mtd><mtd><mo>=</mo></mtd><mtd columnalign="left"><mi mathvariant="monospace">t</mi></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>|</mo></mtd><mtd columnalign="left"><mi mathvariant="monospace">f</mi></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>|</mo></mtd><mtd columnalign="left"><mrow><mo stretchy="false">(</mo><mrow><mi>B</mi><mo>&bull;</mo><mi>B</mi></mrow><mo stretchy="false">)</mo></mrow></mtd></mtr></mtable></math>我们将其当作下列施加于抽象句法树集合<math><mi>B</mi></math>上的约束的缩写:<math display="block"><mtable><mtr><mtd><mrow><mi mathvariant="monospace">t</mi><mo>&in;</mo><mi>B</mi></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant="monospace">f</mi><mo>&in;</mo><mi>B</mi></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mrow><mi>a</mi><mo>&in;</mo><mi>B</mi></mrow><mtext>&nbsp;且&nbsp;</mtext><mrow><mi>b</mi><mo>&in;</mo><mi>B</mi></mrow></mrow><mo>&Implies;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>&bull;</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>B</mi></mrow></mrow></mtd></mtr></mtable></math>从技术上说, <math><mi>B</mi></math>是满足以上约束的最小集合. 为了构造这个集合, 我们先容纳基本元素<math><mi mathvariant="monospace">t</mi></math>和<math><mi mathvariant="monospace">f</mi></math>, 然后归纳地将其中的东西组合成复合元素.</p><p>记号: 我们有时用&quot;<math><mi>B</mi></math>&quot;表示&quot;集合<math><mi>B</mi></math>&quot;, 但有时&quot;<math><mi>B</mi></math>&quot;也代表&quot;<math><mi>B</mi></math>的任意一个元素&quot;. 从上下文来看, 含义总是明确的. 有时, 我们将下标或一撇附加在集合的名字上来集合的任意元素, 例如&quot;<math><msub><mi>B</mi><mn>1</mn></msub></math>&quot;或者&quot;<math><msup><mi>B</mi><mo>&prime;</mo></msup></math>&quot;. 因此, 以上约束也可以写成<math display="block"><mtable><mtr><mtd><mrow><mi mathvariant="monospace">t</mi><mo>&in;</mo><mi>B</mi></mrow></mtd><mtd><mrow><mo stretchy="false">[</mo><mtext>a</mtext><mo stretchy="false">]</mo></mrow></mtd></mtr><mtr><mtd><mrow><mi mathvariant="monospace">f</mi><mo>&in;</mo><mi>B</mi></mrow></mtd><mtd><mrow><mo stretchy="false">[</mo><mtext>b</mtext><mo stretchy="false">]</mo></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>&bull;</mo><msub><mi>B</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>B</mi></mrow></mtd><mtd><mrow><mo stretchy="false">[</mo><mtext>c</mtext><mo stretchy="false">]</mo></mrow></mtd></mtr></mtable></math></p><p>在有限的空间之中枚举出<math><mi>B</mi></math>的所有元素显然是不可能的:<math display="block"><mrow><mi>B</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi mathvariant="monospace">t</mi><mo>,</mo><mi mathvariant="monospace">f</mi><mo>,</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">t</mi><mo>&bull;</mo><mi mathvariant="monospace">t</mi></mrow><mo stretchy="false">)</mo></mrow><mo>,</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">t</mi><mo>&bull;</mo><mi mathvariant="monospace">f</mi></mrow><mo stretchy="false">)</mo></mrow><mo>,</mo><mo>&hellip;</mo></mrow><mo stretchy="false">}</mo></mrow></mrow></math>然而, 给定某个树, 我们可以通过论证它满足约束来证明其属于<math><mi>B</mi></math>. 例如, <math><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">t</mi><mo>&bull;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">f</mi><mo>&bull;</mo><mi mathvariant="monospace">t</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></math>就在<math><mi>B</mi></math>中:<math display="block"><mtable columnalign="left"><mtr><mtd><mtext>1.</mtext></mtd><mtd><mrow><mi mathvariant="monospace">t</mi><mo>&in;</mo><mi>B</mi></mrow></mtd><mtd><mrow><mtext>by&nbsp;</mtext><mrow><mo stretchy="false">[</mo><mtext>a</mtext><mo stretchy="false">]</mo></mrow></mrow></mtd></mtr><mtr><mtd><mtext>2.</mtext></mtd><mtd><mrow><mi mathvariant="monospace">f</mi><mo>&in;</mo><mi>B</mi></mrow></mtd><mtd><mrow><mtext>by&nbsp;</mtext><mrow><mo stretchy="false">[</mo><mtext>b</mtext><mo stretchy="false">]</mo></mrow></mrow></mtd></mtr><mtr><mtd><mtext>3.</mtext></mtd><mtd><mrow><mi mathvariant="monospace">t</mi><mo>&in;</mo><mi>B</mi></mrow></mtd><mtd><mrow><mtext>by&nbsp;</mtext><mrow><mo stretchy="false">[</mo><mtext>a</mtext><mo stretchy="false">]</mo></mrow></mrow></mtd></mtr><mtr><mtd><mtext>4.</mtext></mtd><mtd><mrow><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">f</mi><mo>&bull;</mo><mi mathvariant="monospace">t</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>B</mi></mrow></mtd><mtd><mrow><mtext>by 2, 3, and&nbsp;</mtext><mrow><mo stretchy="false">[</mo><mtext>c</mtext><mo stretchy="false">]</mo></mrow></mrow></mtd></mtr><mtr><mtd><mtext>5.</mtext></mtd><mtd><mrow><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">t</mi><mo>&bull;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">f</mi><mo>&bull;</mo><mi mathvariant="monospace">t</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>B</mi></mrow></mtd><mtd><mrow><mtext>by 1, 4, and&nbsp;</mtext><mrow><mo stretchy="false">[</mo><mtext>c</mtext><mo stretchy="false">]</mo></mrow></mrow></mtd></mtr></mtable></math>通常, 这样的论证也可以被安排成所谓的证明树的形式:<math display="block"><mrow><mfrac displaystyle="true"><mrow><mrow><mrow><mi mathvariant="monospace">t</mi><mo>&in;</mo><mi>B</mi></mrow><mtext>&nbsp;</mtext><mrow><mo stretchy="false">[</mo><mtext>a</mtext><mo stretchy="false">]</mo></mrow></mrow><mspace width="8ex"/><mrow><mfrac displaystyle="true"><mrow><mrow><mrow><mi mathvariant="monospace">f</mi><mo>&in;</mo><mi>B</mi></mrow><mtext>&nbsp;</mtext><mrow><mo stretchy="false">[</mo><mtext>b</mtext><mo stretchy="false">]</mo></mrow></mrow><mspace width="8ex"/><mrow><mrow><mi mathvariant="monospace">t</mi><mo>&in;</mo><mi>B</mi></mrow><mtext>&nbsp;</mtext><mrow><mo stretchy="false">[</mo><mtext>a</mtext><mo stretchy="false">]</mo></mrow></mrow></mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">f</mi><mo>&bull;</mo><mi mathvariant="monospace">t</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>B</mi></mrow></mfrac><mtext>&nbsp;</mtext><mrow><mo stretchy="false">[</mo><mtext>c</mtext><mo stretchy="false">]</mo></mrow></mrow></mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">t</mi><mo>&bull;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">f</mi><mo>&bull;</mo><mi mathvariant="monospace">t</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>B</mi></mrow></mfrac><mtext>&nbsp;</mtext><mrow><mo stretchy="false">[</mo><mtext>c</mtext><mo stretchy="false">]</mo></mrow></mrow></math>绝大多数时候, 证明树以没有标签的形式出现, 因为每一步通常都是显然的:<math display="block"><mfrac displaystyle="true"><mrow><mrow><mi mathvariant="monospace">t</mi><mo>&in;</mo><mi>B</mi></mrow><mspace width="8ex"/><mfrac displaystyle="true"><mrow><mrow><mi mathvariant="monospace">f</mi><mo>&in;</mo><mi>B</mi></mrow><mspace width="8ex"/><mrow><mi mathvariant="monospace">t</mi><mo>&in;</mo><mi>B</mi></mrow></mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">f</mi><mo>&bull;</mo><mi mathvariant="monospace">t</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>B</mi></mrow></mfrac></mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">t</mi><mo>&bull;</mo><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="monospace">f</mi><mo>&bull;</mo><mi mathvariant="monospace">t</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>B</mi></mrow></mfrac></math></p><h4>第1.2节 关系</h4><p>关系是序对的集合. </p><h4>第1.3节 作为等价关系的语义</h4><h4>第1.4节 语义via规约</h4><h4>第1.5节 上下文中的规约</h4><h4>第1.6节 求值函数</h4><h4>第1.7节 记号总结</h4><h3>第2章 分析句法性的语义</h3><h4>第2.1节 从问题到数学声明</h4><h4>第2.2节 作为定理的回答</h4><h3>第3章 <math><mi>&lambda;</mi></math>演算</h3><h3>第4章 ISWIM</h3><h3>第5章 抽象句法机器</h3><h3>第6章 抽象寄存器机器</h3><h4>第6.1节 CC机器</h4><h4>第6.2节 SCC机器</h4><h4>第6.3节 CK机器</h4><h4>第6.4节 CEK机器</h4><h4>第6.5节 历史</h4><h3>第7章 尾调用和更多的空间节省</h3><h3>第8章 控制: 错误, 异常和延续</h3><h3>第9章 状态: 命令式赋值</h3><h3>第10章 简单类型ISWIM</h3></body></html>